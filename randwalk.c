#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <SDL2/SDL.h>

enum config {
	DIR_STEPS = 2,
	WALK_STEPS = 1000000,
	NDIRS = 5,
};

typedef struct rgb {
	unsigned char r;
	unsigned char g;
	unsigned char b;
} rgb;

typedef struct vec2d {
	int x;
	int y;
} vec2d;

typedef struct rw_state {
	vec2d *path;
	rgb *colors;
	size_t pathlen;
	size_t drawn_till;
	size_t max_steps;
} rw_state;

static const vec2d DIRS[NDIRS] = {
	{ 0, 0 },	  { DIR_STEPS, 0 },  { -DIR_STEPS, 0 },
	{ 0, DIR_STEPS }, { 0, -DIR_STEPS },
};

/**
 * Generated by
 * import itertools as it
 * import colorsys as cs
 * cols = map(lambda x: list(map(lambda y: int(255 * y), x)), it.starmap(cs.hsv_to_rgb, [(i/4, 1, 1) for i in range(4)]))
 * for c in cols:
 *     print(f"{{ .r = {c[0]}, .g = {c[1]}, .b = {c[2]} }},")
 */
static const rgb PALLETE[NDIRS] = {
	{ .r = 0, .g = 0, .b = 0 },	{ .r = 255, .g = 0, .b = 0 },
	{ .r = 127, .g = 255, .b = 0 }, { .r = 0, .g = 255, .b = 255 },
	{ .r = 127, .g = 0, .b = 255 },
};
static const vec2d RES = { 1600, 900 };

#define debug() fprintf(stderr, "Line: %d\n", __LINE__)

vec2d vec2d_add(vec2d a, vec2d b)
{
	return (vec2d){ .x = a.x + b.x, .y = a.y + b.y };
}

static rw_state *rw_init(size_t nsteps, vec2d init_pos)
{
	rw_state *ret;
	vec2d *path;
	rgb *colors;

	ret = malloc(sizeof *ret);
	if (!ret) {
		return NULL;
	}
	path = malloc((nsteps + 1) * sizeof *path);
	if (!path) {
		free(ret);
		return NULL;
	}
	colors = malloc(nsteps * sizeof *colors);
	if (!colors) {
		free(ret);
		free(path);
		return NULL;
	}

	path[0] = init_pos;
	*ret = (rw_state){ .path = path,
			   .colors = colors,
			   .max_steps = nsteps };
	return ret;
}

static void rw_destroy(rw_state *rws)
{
	free(rws->colors);
	free(rws->path);
	free(rws);
}

static void rw_draw_path(SDL_Renderer *renr, rw_state *rws)
{
	for (size_t j = rws->drawn_till; j < rws->pathlen; j++) {
		SDL_Rect rect = {
			.h = DIR_STEPS,
			.w = DIR_STEPS,
			.x = rws->path[j].x,
			.y = rws->path[j].y,
		};
		SDL_SetRenderDrawColor(renr, rws->colors[j].r, rws->colors[j].g,
				       rws->colors[j].b, 0);
		SDL_RenderFillRect(renr, &rect);
		SDL_RenderDrawRect(renr, &rect);
	}
	rws->drawn_till = rws->pathlen;
}

static inline void rw_nstep(rw_state *rws, size_t n)
{
	for (size_t i = 0; i < n && rws->pathlen < rws->max_steps; i++) {
		int dir = rand() % NDIRS;
		vec2d pos = rws->path[rws->pathlen];
		pos = vec2d_add(pos, DIRS[dir]);
		pos.x = ((pos.x % RES.x) + RES.x) % RES.x;
		pos.y = ((pos.y % RES.y) + RES.y) % RES.y;

		rws->colors[rws->pathlen] = PALLETE[dir];
		rws->path[++rws->pathlen] = pos;
	}
}

int main()
{
	srand(time(NULL));
	int exit_status = EXIT_SUCCESS;
	int quit = 0;
	SDL_Event event = { 0 };

	// Ew...
	if (SDL_Init(SDL_INIT_VIDEO) < 0) {
		exit_status = EXIT_FAILURE;
		goto err;
	}
	SDL_Window *win = SDL_CreateWindow("Maze gen!!!1",
					   SDL_WINDOWPOS_CENTERED,
					   SDL_WINDOWPOS_CENTERED, RES.x, RES.y,
					   SDL_WINDOW_SHOWN);
	if (!win) {
		SDL_Quit();
		exit_status = EXIT_FAILURE;
		goto err;
	}
	SDL_Renderer *renr = SDL_CreateRenderer(
		win, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
	if (!renr) {
		SDL_DestroyWindow(win);
		SDL_Quit();
		exit_status = EXIT_FAILURE;
		goto err;
	}
	SDL_Texture *rentex = SDL_CreateTexture(renr, SDL_PIXELFORMAT_RGBA8888,
						SDL_TEXTUREACCESS_TARGET, RES.x,
						RES.y);
	if (!rentex) {
		SDL_DestroyRenderer(renr);
		SDL_DestroyWindow(win);
		SDL_Quit();
		exit_status = EXIT_FAILURE;
		goto err;
	}
	rw_state *rws = rw_init(WALK_STEPS, (vec2d){ RES.x / 2, RES.y / 2 });
	if (!rws) {
		SDL_DestroyTexture(rentex);
		SDL_DestroyRenderer(renr);
		SDL_DestroyWindow(win);
		SDL_Quit();
		goto err;
	}

	while (!quit) {
		while (SDL_PollEvent(&event)) {
			switch (event.type) {
			case SDL_QUIT:
				quit = 1;
				break;

			default:
				break;
			}
		}

		/* Draw to the texture instead of drawing all over again, incremental */
		SDL_SetRenderTarget(renr, rentex);
		rw_nstep(rws, 100);
		rw_draw_path(renr, rws);

		SDL_SetRenderTarget(renr, NULL);
		SDL_RenderCopy(renr, rentex, NULL, NULL);

		SDL_RenderPresent(renr);
		SDL_SetRenderDrawColor(renr, 0, 0, 0, 0);
		SDL_RenderClear(renr);
	}

	/* Write netpbm .ppm P6(24-bit RGB binary format) image to stdout */
	// puts("P6");
	// printf("%d %d\n", RES.x, RES.y);
	// puts("255");
	// for (size_t i = 0; i < n; i++) {
	// 	rgb color = PALLETE[(int)path[i]];
	// 	fwrite(&color, 3 * sizeof(color.r), 1, stdout);
	// }
	// putchar('\n');

	rw_destroy(rws);
	SDL_DestroyTexture(rentex);
	SDL_DestroyRenderer(renr);
	SDL_DestroyWindow(win);
	SDL_Quit();
err:
	return exit_status;
}
